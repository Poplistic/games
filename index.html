<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>Capitol Dome Control</title>

<style>
  body {
    margin: 0;
    overflow: hidden;
    background: #000;
    color: white;
    font-family: Arial, sans-serif;
  }

  #ui {
    position: absolute;
    top: 10px;
    left: 10px;
    z-index: 10;
    background: rgba(0,0,0,0.6);
    padding: 10px;
    border-radius: 6px;
  }

  textarea, input, button {
    width: 220px;
    margin-top: 6px;
  }

  button {
    cursor: pointer;
  }
</style>
</head>
<body>

<div id="ui">
  <textarea id="text" placeholder="CAPITOL ANNOUNCEMENT"></textarea>
  <button onclick="sendAnnouncement()">Broadcast Announcement</button>
</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>

<script>
/* ================= CONFIG ================= */

const API_URL = "https://YOUR_RENDER_URL.onrender.com";
const PANEL_COUNT = 24;
const RADIUS = 120;

/* ================= THREE.JS SETUP ================= */

const scene = new THREE.Scene();
scene.background = new THREE.Color(0x000000);

const camera = new THREE.PerspectiveCamera(
  60,
  window.innerWidth / window.innerHeight,
  1,
  1000
);
camera.position.set(0, 80, 220);

const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

/* ================= LIGHT ================= */

scene.add(new THREE.AmbientLight(0xffffff, 1));

/* ================= DOME PANELS ================= */

const panels = [];
const selectedPanels = new Set();

for (let i = 0; i < PANEL_COUNT; i++) {
  const geometry = new THREE.BoxGeometry(30, 60, 2);
  const material = new THREE.MeshBasicMaterial({ color: 0x333333 });
  const panel = new THREE.Mesh(geometry, material);

  const angle = (i / PANEL_COUNT) * Math.PI * 2;

  panel.position.set(
    Math.cos(angle) * RADIUS,
    0,
    Math.sin(angle) * RADIUS
  );

  panel.rotation.y = -angle;
  panel.userData.index = i + 1;

  scene.add(panel);
  panels.push(panel);
}

/* ================= RAYCASTING ================= */

const raycaster = new THREE.Raycaster();
const mouse = new THREE.Vector2();

window.addEventListener("click", (event) => {
  mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
  mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

  raycaster.setFromCamera(mouse, camera);
  const intersects = raycaster.intersectObjects(panels);

  if (intersects.length > 0) {
    const panel = intersects[0].object;
    const id = panel.userData.index;

    if (selectedPanels.has(id)) {
      selectedPanels.delete(id);
      panel.material.color.set(0x333333);
    } else {
      selectedPanels.add(id);
      panel.material.color.set(0xffcc00);
    }
  }
});

/* ================= API ================= */

function sendAnnouncement() {
  fetch(`${API_URL}/announcement`, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({
      text: document.getElementById("text").value,
      panels: Array.from(selectedPanels)
    })
  });
}

/* ================= ANIMATION ================= */

function animate() {
  requestAnimationFrame(animate);
  scene.rotation.y += 0.002;
  renderer.render(scene, camera);
}

animate();

/* ================= RESIZE ================= */

window.addEventListener("resize", () => {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>

</body>
</html>
