<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Spectator Map</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<style>
	body { margin:0; overflow:hidden; background:black; }
	.ui {
		position:absolute;
		color:white;
		font-family:sans-serif;
		background:rgba(0,0,0,.6);
		padding:6px;
		font-size:12px;
	}
	input { background:#111; color:white; border:1px solid #333; }
</style>
</head>
<body>

<script src="https://cdn.socket.io/4.7.5/socket.io.min.js"></script>

<script type="module">
import * as THREE from "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js";
import { OrbitControls } from "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/controls/OrbitControls.js";

/* ======================
   THREE SETUP
====================== */
const renderer = new THREE.WebGLRenderer({ antialias:true });
renderer.setSize(innerWidth, innerHeight);
document.body.appendChild(renderer.domElement);

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(60, innerWidth/innerHeight, 1, 15000);
camera.position.set(2000,2000,2000);

const controls = new OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;

/* ======================
   GROUPS
====================== */
const playerGroup = new THREE.Group();
const spectatorGroup = new THREE.Group();
scene.add(playerGroup, spectatorGroup);

/* ======================
   UI
====================== */
const tributeUI = ui("10px","10px");
const killUI = ui("10px",null,"10px");
const chatUI = ui(null,"10px","10px");

chatUI.innerHTML = `
	<div id="log" style="height:120px;overflow:auto"></div>
	<input id="input" placeholder="chat" style="width:100%">
`;

function ui(top,left,right){
	const d=document.createElement("div");
	d.className="ui";
	if(top) d.style.top=top;
	if(left) d.style.left=left;
	if(right) d.style.right=right;
	document.body.appendChild(d);
	return d;
}

/* ======================
   STATE
====================== */
const players = new Map();
let tracked = null;
let followMode = "behind";

/* ======================
   PLAYER MARKER
====================== */
function makePlayer() {
	const dot = new THREE.Mesh(
		new THREE.SphereGeometry(8),
		new THREE.MeshBasicMaterial({ color:0x00ff00 })
	);

	const hit = new THREE.Mesh(
		new THREE.SphereGeometry(40),
		new THREE.MeshBasicMaterial({ transparent:true, opacity:0 })
	);
	hit.userData.isHitbox = true;
	dot.add(hit);

	const arrow = new THREE.ArrowHelper(
		new THREE.Vector3(0,0,1),
		new THREE.Vector3(),
		80,
		0xffff00
	);
	dot.add(arrow);

	dot.userData.arrow = arrow;
	return dot;
}

/* ======================
   FETCH PLAYERS (5Hz)
====================== */
async function updatePlayers() {
	const data = await fetch("/map").then(r=>r.json());

	tributeUI.innerHTML =
		"<b>Tributes</b><br>" +
		data.map(p=>p.name).join("<br>");

	for (const p of data) {
		if (!players.has(p.id)) {
			const m = makePlayer();
			playerGroup.add(m);
			players.set(p.id, m);
		}

		const m = players.get(p.id);

		/* === TERRAIN HEIGHT CORRECTION === */
		const targetPos = new THREE.Vector3(
			p.x,
			(p.y || 0) + 6,
			p.z
		);
		m.position.lerp(targetPos, 0.35);

		/* === LOOK DIRECTION ARROW === */
		if (p.lookX !== undefined) {
			const dir = new THREE.Vector3(p.lookX, 0, p.lookZ).normalize();
			m.userData.arrow.setDirection(dir);
		}
	}
}

setInterval(updatePlayers, 200);

/* ======================
   CLICK TRACK (MOBILE SAFE)
====================== */
const ray = new THREE.Raycaster();
const mouse = new THREE.Vector2();

window.addEventListener("pointerdown", e=>{
	mouse.x=(e.clientX/innerWidth)*2-1;
	mouse.y=-(e.clientY/innerHeight)*2+1;
	ray.setFromCamera(mouse,camera);

	const hits = ray.intersectObjects(playerGroup.children,true)
		.filter(h=>h.object.userData.isHitbox);

	if (hits[0]) tracked = hits[0].object.parent;
});

/* ======================
   FOLLOW CAM
====================== */
window.addEventListener("keydown", e=>{
	if (e.key==="1") followMode="behind";
	if (e.key==="2") followMode="overhead";
	if (e.key==="3") followMode="free";
});

function follow() {
	if (!tracked || followMode==="free") return;

	/* === SPEED ESTIMATION === */
	if (lastTrackedPos) {
		trackedVelocity = tracked.position.distanceTo(lastTrackedPos);
	}
	lastTrackedPos = tracked.position.clone();

	const speedZoom = THREE.MathUtils.clamp(trackedVelocity * 6, 0, 1200);

	let offset;
	if (followMode === "behind") {
		offset = new THREE.Vector3(
			0,
			300 + speedZoom * 0.3,
			700 + speedZoom
		);
	} else {
		offset = new THREE.Vector3(
			0,
			1200 + speedZoom,
			0
		);
	}

	camera.position.lerp(tracked.position.clone().add(offset), 0.08);
	camera.lookAt(tracked.position);
}

/* ======================
   SOCKET.IO
====================== */
const socket = io();

socket.on("spectators:init", list=>{
	list.forEach(s=>{
		const m=new THREE.Mesh(
			new THREE.SphereGeometry(12),
			new THREE.MeshBasicMaterial({ color:s.color })
		);
		m.userData.id=s.id;
		spectatorGroup.add(m);
	});
});

socket.on("spectator:update", s=>{
	const m=[...spectatorGroup.children].find(x=>x.userData.id===s.id);
	if (m) m.position.set(s.pos.x,s.pos.y,s.pos.z);
});

socket.on("chat:msg", m=>{
	const log=document.getElementById("log");
	log.innerHTML+=`<div><b>${m.from}:</b> ${m.msg}</div>`;
	log.scrollTop=log.scrollHeight;
});

document.getElementById("input").addEventListener("keydown",e=>{
	if(e.key==="Enter"&&e.target.value){
		socket.emit("chat:send",e.target.value);
		e.target.value="";
	}
});

socket.on("kill:feed", list=>{
	killUI.innerHTML =
		"<b>Kills</b><br>" +
		list.map(k=>`${k.killer} â˜  ${k.victim}`).join("<br>");
});

/* ======================
   SEND CAMERA
====================== */
setInterval(()=>{
	const dir=new THREE.Vector3();
	camera.getWorldDirection(dir);
	socket.emit("spectator:update",{ pos:camera.position, dir });
},120);

/* ======================
   RESIZE
====================== */
addEventListener("resize",()=>{
	camera.aspect=innerWidth/innerHeight;
	camera.updateProjectionMatrix();
	renderer.setSize(innerWidth,innerHeight);
});

/* ======================
   LOOP (RENDER ONLY)
====================== */
function animate(){
	requestAnimationFrame(animate);
	follow();
	controls.update();
	renderer.render(scene,camera);
}
animate();
</script>
</body>
</html>
