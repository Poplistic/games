<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>HG Arena â€“ Roblox Lighting Sync</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<style>
	html, body {
		margin: 0;
		width: 100%;
		height: 100%;
		overflow: hidden;
		background: #02030a;
	}
	canvas { display: block; }
</style>

<script type="importmap">
{
  "imports": {
    "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js"
  }
}
</script>
</head>

<body>

<script type="module">
import * as THREE from "three";
import { OrbitControls } from "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/controls/OrbitControls.js";
import { EffectComposer } from "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/postprocessing/EffectComposer.js";
import { RenderPass } from "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/postprocessing/RenderPass.js";
import { ShaderPass } from "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/postprocessing/ShaderPass.js";
import { UnrealBloomPass } from "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/postprocessing/UnrealBloomPass.js";
import { OBJLoader } from "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/loaders/OBJLoader.js";

/* ======================
   RENDERER
====================== */

const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(innerWidth, innerHeight);
renderer.setPixelRatio(devicePixelRatio);
renderer.outputColorSpace = THREE.SRGBColorSpace;
document.body.appendChild(renderer.domElement);

const depthTexture = new THREE.DepthTexture();

/* ======================
   SCENE / CAMERA
====================== */

const scene = new THREE.Scene();
scene.fog = new THREE.FogExp2(0x050914, 0.00035);

const camera = new THREE.PerspectiveCamera(60, innerWidth / innerHeight, 1, 9000);
camera.position.set(1800, 1400, 1800);

/* ======================
   ROBLOX SKY
====================== */

const skyMat = new THREE.ShaderMaterial({
	side: THREE.BackSide,
	uniforms: {
		sunY: { value: 1 },
		topDay: { value: new THREE.Color(0x87ceeb) },
		horizonDay: { value: new THREE.Color(0xffcc88) },
		topNight: { value: new THREE.Color(0x02030a) },
		horizonNight: { value: new THREE.Color(0x050914) }
	},
	vertexShader: `
		varying vec3 vPos;
		void main() {
			vPos = position;
			gl_Position = projectionMatrix * modelViewMatrix * vec4(position,1.0);
		}
	`,
	fragmentShader: `
		uniform float sunY;
		uniform vec3 topDay;
		uniform vec3 horizonDay;
		uniform vec3 topNight;
		uniform vec3 horizonNight;
		varying vec3 vPos;

		void main() {
			float h = normalize(vPos).y * 0.5 + 0.5;
			float day = clamp(sunY * 0.5 + 0.5, 0.0, 1.0);
			vec3 top = mix(topNight, topDay, day);
			vec3 horizon = mix(horizonNight, horizonDay, day);
			gl_FragColor = vec4(mix(horizon, top, h), 1.0);
		}
	`
});

scene.add(new THREE.Mesh(
	new THREE.SphereGeometry(8000, 32, 32),
	skyMat
));

/* ======================
   CONTROLS
====================== */

const controls = new OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;

/* ======================
   LIGHTING
====================== */

scene.add(new THREE.AmbientLight(0x223366, 0.45));

const sun = new THREE.DirectionalLight(0x99ccff, 1.8);
scene.add(sun);

/* ======================
   ARENA
====================== */

new OBJLoader().load("./arena.obj", obj => {
	obj.traverse(m => {
		if (!m.isMesh) return;
		m.material = new THREE.MeshStandardMaterial({
			color: 0x0a1022,
			roughness: 0.85,
			metalness: 0.15,
			emissive: 0x03060f
		});
	});
	scene.add(obj);
});

/* ======================
   ROBLOX LIGHTING STATE
====================== */

let lighting = {
	clockTime: 12,
	fogColor: [5, 9, 20],
	fogDensity: 0.00035
};

async function updateLighting() {
	try {
		lighting = await fetch("/lighting").then(r => r.json());
	} catch {}
}
setInterval(updateLighting, 1000);

/* ======================
   SUN FROM CLOCKTIME
====================== */

function sunFromClockTime(clockTime) {
	const angle = (clockTime / 24) * Math.PI * 2 - Math.PI / 2;
	return new THREE.Vector3(
		Math.cos(angle),
		Math.sin(angle),
		0.35
	).normalize();
}

/* ======================
   TRUE VOLUMETRIC GOD RAYS
====================== */

const GodRayPass = new ShaderPass({
	uniforms: {
		tDiffuse: { value: null },
		tDepth: { value: depthTexture },
		cameraNear: { value: camera.near },
		cameraFar: { value: camera.far },
		lightDir: { value: new THREE.Vector3() }
	},
	vertexShader: `
		varying vec2 vUv;
		void main() {
			vUv = uv;
			gl_Position = vec4(position.xy,0.0,1.0);
		}
	`,
	fragmentShader: `
		#include <packing>
		uniform sampler2D tDiffuse;
		uniform sampler2D tDepth;
		uniform float cameraNear;
		uniform float cameraFar;
		uniform vec3 lightDir;
		varying vec2 vUv;

		float readDepth(vec2 uv) {
			float z = texture2D(tDepth, uv).x;
			return perspectiveDepthToViewZ(z, cameraNear, cameraFar);
		}

		void main() {
			vec3 base = texture2D(tDiffuse, vUv).rgb;
			float depth = -readDepth(vUv);
			vec3 col = vec3(0.0);

			float stepSize = depth / 32.0;
			for (int i = 0; i < 32; i++) {
				float t = float(i) * stepSize;
				float fog = exp(-t * 0.002);
				col += vec3(0.4,0.6,1.0) * fog * 0.02;
			}

			gl_FragColor = vec4(base + col, 1.0);
		}
	`
});

/* ======================
   POSTPROCESS
====================== */

const composer = new EffectComposer(renderer);
composer.renderTarget1.depthTexture = depthTexture;
composer.renderTarget2.depthTexture = depthTexture;

composer.addPass(new RenderPass(scene, camera));
composer.addPass(new UnrealBloomPass(
	new THREE.Vector2(innerWidth, innerHeight),
	1.1, 0.55, 0.15
));
composer.addPass(GodRayPass);

/* ======================
   ANIMATE
====================== */

function animate() {
	requestAnimationFrame(animate);
	controls.update();

	const sunDir = sunFromClockTime(lighting.clockTime);

	sun.position.copy(sunDir).multiplyScalar(3000);
	skyMat.uniforms.sunY.value = sunDir.y;

	scene.fog.color.setRGB(
		lighting.fogColor[0] / 255,
		lighting.fogColor[1] / 255,
		lighting.fogColor[2] / 255
	);
	scene.fog.density = lighting.fogDensity;

	GodRayPass.uniforms.lightDir.value.copy(sunDir);

	composer.render();
}
animate();

/* ======================
   RESIZE
====================== */

addEventListener("resize", () => {
	camera.aspect = innerWidth / innerHeight;
	camera.updateProjectionMatrix();
	renderer.setSize(innerWidth, innerHeight);
	composer.setSize(innerWidth, innerHeight);
});
</script>

</body>
</html>
