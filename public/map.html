<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>HG Live Map</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<style>
	body { margin: 0; overflow: hidden; background: #000; }
	.label {
		position: absolute;
		color: white;
		font-family: sans-serif;
		font-size: 12px;
		pointer-events: none;
		text-shadow: 0 0 4px black;
	}
</style>
</head>

<body>

<!-- Socket.IO -->
<script src="https://cdn.socket.io/4.7.5/socket.io.min.js"></script>

<script type="module">
/* ======================
   THREE IMPORTS (FIXED)
====================== */
import * as THREE from "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js";
import { OrbitControls } from "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/controls/OrbitControls.js";
import { Sky } from "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/objects/Sky.js";

/* ======================
   BASIC SETUP
====================== */
const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(innerWidth, innerHeight);
renderer.setPixelRatio(devicePixelRatio);
renderer.outputColorSpace = THREE.SRGBColorSpace;
document.body.appendChild(renderer.domElement);

const scene = new THREE.Scene();

const camera = new THREE.PerspectiveCamera(60, innerWidth / innerHeight, 1, 15000);
camera.position.set(2000, 1800, 2000);

const controls = new OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;

/* ======================
   SKY + LIGHT
====================== */
const sky = new Sky();
sky.scale.setScalar(10000);
scene.add(sky);

const sun = new THREE.Vector3();
scene.add(new THREE.AmbientLight(0x404060, 0.4));

const dirLight = new THREE.DirectionalLight(0xffffff, 3);
scene.add(dirLight);

/* ======================
   GROUPS
====================== */
const playerGroup = new THREE.Group();
const spectatorGroup = new THREE.Group();
scene.add(playerGroup, spectatorGroup);

/* ======================
   STATE
====================== */
const playerSprites = new Map();
const spectatorMeshes = new Map();
let trackedPlayerId = null;

/* ======================
   HELPERS
====================== */
function lerp(a, b, t) {
	return a + (b - a) * t;
}

function smoothVec(v, target, t) {
	v.x = lerp(v.x, target.x, t);
	v.y = lerp(v.y, target.y, t);
	v.z = lerp(v.z, target.z, t);
}

/* ======================
   PLAYER DOT (SMALL + CLICKABLE)
====================== */
function makePlayerDot() {
	const dot = new THREE.Mesh(
		new THREE.SphereGeometry(8, 12, 12),
		new THREE.MeshBasicMaterial({ color: 0x00ff00 })
	);

	// Invisible big hitbox (mobile friendly)
	const hitbox = new THREE.Mesh(
		new THREE.SphereGeometry(40, 8, 8),
		new THREE.MeshBasicMaterial({ transparent: true, opacity: 0 })
	);

	dot.add(hitbox);
	dot.userData.hitbox = hitbox;
	return dot;
}

/* ======================
   PLAYER LABEL
====================== */
function makeLabel() {
	const el = document.createElement("div");
	el.className = "label";
	document.body.appendChild(el);
	return el;
}

/* ======================
   UPDATE PLAYERS
====================== */
async function updatePlayers() {
	const data = await fetch("/map").then(r => r.json());

	for (const p of data) {
		if (!playerSprites.has(p.id)) {
			const mesh = makePlayerDot();
			mesh.userData.id = p.id;
			mesh.userData.label = makeLabel();
			playerGroup.add(mesh);
			playerSprites.set(p.id, mesh);
		}

		const m = playerSprites.get(p.id);
		smoothVec(m.position, { x: p.x, y: 50, z: p.z }, 0.35);

		const dist = camera.position.distanceTo(m.position).toFixed(0);
		m.userData.label.innerText = `${p.name} â€¢ ${dist}m`;
	}
}

/* ======================
   CLICK TO TRACK PLAYER
====================== */
const raycaster = new THREE.Raycaster();
const mouse = new THREE.Vector2();

function onClick(e) {
	mouse.x = (e.clientX / innerWidth) * 2 - 1;
	mouse.y = -(e.clientY / innerHeight) * 2 + 1;

	raycaster.setFromCamera(mouse, camera);
	const hits = raycaster.intersectObjects(playerGroup.children, true);

	if (hits.length) {
		trackedPlayerId = hits[0].object.parent.userData.id;
	}
}

window.addEventListener("pointerdown", onClick);

/* ======================
   AUTO FOLLOW CAM
====================== */
function followPlayer() {
	if (!trackedPlayerId) return;
	const m = playerSprites.get(trackedPlayerId);
	if (!m) return;

	const offset = new THREE.Vector3(0, 600, 800);
	const targetPos = m.position.clone().add(offset);

	smoothVec(camera.position, targetPos, 0.08);
	camera.lookAt(m.position);
}

/* ======================
   SPECTATORS (SOCKET.IO)
====================== */
const socket = io();

socket.on("spectators:init", list => {
	list.forEach(addSpectator);
});

socket.on("spectator:join", addSpectator);
socket.on("spectator:update", updateSpectator);
socket.on("spectator:leave", id => {
	const m = spectatorMeshes.get(id);
	if (m) {
		spectatorGroup.remove(m);
		spectatorMeshes.delete(id);
	}
});

function addSpectator(s) {
	if (spectatorMeshes.has(s.id)) return;

	const mesh = new THREE.Mesh(
		new THREE.SphereGeometry(12, 12, 12),
		new THREE.MeshBasicMaterial({ color: s.color })
	);

	spectatorGroup.add(mesh);
	spectatorMeshes.set(s.id, mesh);
}

function updateSpectator(s) {
	const m = spectatorMeshes.get(s.id);
	if (!m) return;
	m.position.set(s.pos.x, s.pos.y, s.pos.z);
}

/* Send our camera */
setInterval(() => {
	const dir = new THREE.Vector3();
	camera.getWorldDirection(dir);

	socket.emit("spectator:update", {
		pos: camera.position,
		dir
	});
}, 120);

/* ======================
   ANIMATE
====================== */
async function animate() {
	requestAnimationFrame(animate);

	await updatePlayers();
	followPlayer();

	for (const m of playerSprites.values()) {
		const p = m.position.clone().project(camera);
		const x = (p.x * 0.5 + 0.5) * innerWidth;
		const y = (-p.y * 0.5 + 0.5) * innerHeight;
		m.userData.label.style.transform = `translate(${x}px,${y}px)`;
	}

	controls.update();
	renderer.render(scene, camera);
}

animate();
</script>
</body>
</html>
