<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Spectator Map</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<style>
	body { margin:0; overflow:hidden; background:black; }
	canvas { display:block }

	.ui {
		position:absolute;
		color:white;
		font-family:system-ui,sans-serif;
		background:rgba(20,20,20,.65);
		backdrop-filter: blur(6px);
		border:1px solid rgba(255,255,255,.1);
		border-radius:8px;
		padding:8px 10px;
		font-size:12px;
		box-shadow:0 0 20px rgba(0,0,0,.6);
	}

	input {
		width:100%;
		box-sizing:border-box;
		background:#111;
		color:white;
		border:1px solid #333;
		border-radius:4px;
		padding:4px;
	}
</style>

<script type="importmap">
{
  "imports": {
    "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js"
  }
}
</script>
</head>

<body>
<script src="https://cdn.socket.io/4.7.5/socket.io.min.js"></script>

<script type="module">
import * as THREE from "three";
import { OrbitControls } from "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/controls/OrbitControls.js";
import { OBJLoader } from "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/loaders/OBJLoader.js";

/* ======================
   BASIC SETUP
====================== */
const renderer = new THREE.WebGLRenderer({ antialias:true });
renderer.setSize(innerWidth, innerHeight);
renderer.setPixelRatio(devicePixelRatio);
document.body.appendChild(renderer.domElement);

const scene = new THREE.Scene();
scene.background = new THREE.Color(0x050508);

const camera = new THREE.PerspectiveCamera(60, innerWidth/innerHeight, 1, 20000);
camera.position.set(2000,2000,2000);

const controls = new OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;

/* ======================
   LIGHTING
====================== */
scene.add(new THREE.AmbientLight(0xffffff, 0.35));
const sun = new THREE.DirectionalLight(0xffffff, 1.1);
sun.position.set(3000,6000,2000);
scene.add(sun);

/* ======================
   GROUPS
====================== */
const playerGroup = new THREE.Group();
scene.add(playerGroup);

/* ======================
   LOAD ARENA
====================== */
let terrainMesh = null;
new OBJLoader().load("arena.obj", obj=>{
	scene.add(obj);
	terrainMesh = obj;
});

/* ======================
   PLAYER CREATION
====================== */
const players = new Map();

function makePlayer(name){
	const m = new THREE.Mesh(
		new THREE.SphereGeometry(10,16,16),
		new THREE.MeshStandardMaterial({ color:0x00ff00 })
	);

	const arrow = new THREE.Group();
	const armGeo = new THREE.BoxGeometry(3,18,3);
	const mat = new THREE.MeshStandardMaterial({ color:0xffff00 });

	const a1 = new THREE.Mesh(armGeo, mat);
	a1.rotation.z = Math.PI/4;
	a1.position.y = 6;

	const a2 = new THREE.Mesh(armGeo, mat);
	a2.rotation.z = -Math.PI/4;
	a2.position.y = -6;

	arrow.add(a1,a2);
	arrow.position.y = 36;
	m.add(arrow);

	m.userData = {
		pos: new THREE.Vector3(),
		vel: new THREE.Vector3(),
		target: new THREE.Vector3(),
		lastUpdate: performance.now(),

		// LOOK STATE
		lastYaw: 0,
		yawVelocity: 0,
		lastLookTime: performance.now(),

		arrow,
		arrowAngle: 0
	};

	return m;
}

/* ======================
   SERVER SNAPSHOT
====================== */
async function updatePlayers(){
	const now = performance.now();
	const data = await fetch("/map").then(r=>r.json());
	const active = new Set();

	for(const p of data){
		active.add(p.id);

		if(!players.has(p.id)){
			const m = makePlayer(p.name);
			playerGroup.add(m);
			players.set(p.id,m);
		}

		const m = players.get(p.id);
		const u = m.userData;

		const newPos = new THREE.Vector3(p.x,0,p.z);
		const dt = Math.max((now - u.lastUpdate)/1000, 0.001);

		u.vel.copy(newPos).sub(u.pos).divideScalar(dt);
		u.pos.copy(newPos);
		u.lastUpdate = now;

		/* LOOK SNAPSHOT */
		if(p.lookX !== undefined){
			const yaw = -Math.atan2(p.lookX, p.lookZ);
			const dy = THREE.MathUtils.angleDifference(yaw, u.lastYaw);
			u.yawVelocity = dy / dt;
			u.lastYaw = yaw;
			u.lastLookTime = now;
		}
	}

	for(const [id,m] of players){
		if(!active.has(id)){
			playerGroup.remove(m);
			players.delete(id);
		}
	}
}
setInterval(updatePlayers,200);

/* ======================
   LOOP (PREDICTION)
====================== */
function animate(){
	requestAnimationFrame(animate);

	for(const m of playerGroup.children){
		const u = m.userData;

		/* Position prediction */
		u.target.copy(u.pos).addScaledVector(u.vel, 0.12);
		m.position.lerp(u.target, 0.15);

		/* LOOK PREDICTION (ZERO LATENCY) */
		const predictTime = 0.14; // ~140ms
		const predictedYaw =
			u.lastYaw + u.yawVelocity * predictTime;

		u.arrowAngle = THREE.MathUtils.lerp(
			u.arrowAngle,
			predictedYaw,
			0.25
		);

		u.arrow.rotation.y = u.arrowAngle;
	}

	controls.update();
	renderer.render(scene,camera);
}
animate();

/* ======================
   RESIZE
====================== */
addEventListener("resize",()=>{
	camera.aspect = innerWidth/innerHeight;
	camera.updateProjectionMatrix();
	renderer.setSize(innerWidth, innerHeight);
});
</script>
</body>
</html>
