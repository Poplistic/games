<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Spectator Map</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<style>
body { margin:0; overflow:hidden; background:#02040a; }
canvas { display:block }

.ui {
	position:absolute;
	color:#aefcff;
	font-family:system-ui,sans-serif;
	background:linear-gradient(180deg,rgba(0,255,255,.18),rgba(0,60,60,.05));
	backdrop-filter:blur(12px) saturate(150%);
	border:1px solid rgba(0,255,255,.4);
	border-radius:12px;
	padding:10px;
	font-size:12px;
	box-shadow:0 0 25px rgba(0,255,255,.35), inset 0 0 30px rgba(0,255,255,.1);
}

.name { cursor:pointer; padding:4px 6px; border-radius:6px }
.name:hover { background:rgba(0,255,255,.18) }
</style>

<script type="importmap">
{
  "imports": {
    "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js"
  }
}
</script>
</head>

<body>

<a href="/fallen.html" target="_blank"
style="position:absolute;top:12px;right:12px;color:#aefcff;
background:linear-gradient(180deg,rgba(0,255,255,.25),rgba(0,80,80,.1));
border:1px solid rgba(0,255,255,.5);
padding:10px 16px;border-radius:10px;text-decoration:none;">
Fallen Tributes
</a>

<script src="https://cdn.socket.io/4.7.5/socket.io.min.js"></script>

<script type="module">
import * as THREE from "three";
import { OBJLoader } from "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/loaders/OBJLoader.js";
import {
	acceleratedRaycast,
	computeBoundsTree,
	disposeBoundsTree
} from "https://cdn.jsdelivr.net/npm/three-mesh-bvh@0.7.4/build/index.module.js";

/* ================= BVH PATCH ================= */
THREE.Mesh.prototype.raycast = acceleratedRaycast;
THREE.BufferGeometry.prototype.computeBoundsTree = computeBoundsTree;
THREE.BufferGeometry.prototype.disposeBoundsTree = disposeBoundsTree;

/* ================= RENDERER ================= */
const renderer = new THREE.WebGLRenderer({ antialias:true });
renderer.setSize(innerWidth, innerHeight);
renderer.setPixelRatio(devicePixelRatio);
renderer.outputColorSpace = THREE.SRGBColorSpace;
renderer.toneMapping = THREE.ACESFilmicToneMapping;
document.body.appendChild(renderer.domElement);

const scene = new THREE.Scene();
scene.background = new THREE.Color(0x02040a);

const camera = new THREE.PerspectiveCamera(60, innerWidth/innerHeight, 1, 30000);
camera.position.set(0,1200,1800);

/* ================= LIGHT ================= */
scene.add(new THREE.AmbientLight(0xffffff,0.35));
const sun = new THREE.DirectionalLight(0xffffff,1.1);
sun.position.set(3000,6000,2000);
scene.add(sun);

/* ================= UI ================= */
const tributeUI = ui("10px","10px");
function ui(t,l){
	const d=document.createElement("div");
	d.className="ui";
	d.style.top=t; d.style.left=l;
	document.body.appendChild(d);
	return d;
}

/* ================= CAMERA STATE ================= */
const cam = {
	vel:new THREE.Vector3(),
	accel:2600,
	damping:10,
	max:1800,
	yaw:0,
	pitch:0,
	input:{f:0,r:0,u:0},
	follow:null
};

/* ================= INPUT ================= */
addEventListener("keydown",e=>{
	if(e.code==="KeyW") cam.input.f=1;
	if(e.code==="KeyS") cam.input.f=-1;
	if(e.code==="KeyA") cam.input.r=-1;
	if(e.code==="KeyD") cam.input.r=1;
	if(e.code==="Space") cam.input.u=1;
	if(e.code==="ShiftLeft") cam.input.u=-1;
});
addEventListener("keyup",e=>{
	if(["KeyW","KeyS"].includes(e.code)) cam.input.f=0;
	if(["KeyA","KeyD"].includes(e.code)) cam.input.r=0;
	if(["Space","ShiftLeft"].includes(e.code)) cam.input.u=0;
});

renderer.domElement.addEventListener("mousedown",e=>{
	if(e.button===2) renderer.domElement.requestPointerLock();
});
addEventListener("mousemove",e=>{
	if(document.pointerLockElement){
		cam.yaw-=e.movementX*0.002;
		cam.pitch=Math.max(-1.5,Math.min(1.5,cam.pitch-e.movementY*0.002));
	}
});
addEventListener("contextmenu",e=>e.preventDefault());

/* ================= SHADER (OPAQUE) ================= */
const holoMat = new THREE.ShaderMaterial({
	vertexShader:`
	varying vec3 vPos;
	void main(){
		vPos=position;
		gl_Position=projectionMatrix*modelViewMatrix*vec4(position,1.);
	}`,
	fragmentShader:`
	uniform float iTime;
	varying vec3 vPos;
	void main(){
		float scan=sin(vPos.y*0.12+iTime*6.)*0.08;
		gl_FragColor=vec4(0.,.8,1.,1.);
	}`,
	uniforms:{ iTime:{value:0} },
	depthWrite:true
});

/* ================= ARENA ================= */
const arenaMeshes=[];
new OBJLoader().load("/arena.obj",obj=>{
	obj.traverse(c=>{
		if(c.isMesh){
			c.geometry.computeVertexNormals();
			c.geometry.computeBoundsTree();
			c.material=holoMat;
			arenaMeshes.push(c);
		}
	});
	scene.add(obj);
});

/* ================= PLAYERS ================= */
const group=new THREE.Group();
scene.add(group);
const players=new Map();

function makePlayer(){
	return new THREE.Mesh(
		new THREE.SphereGeometry(10,32,32),
		new THREE.MeshStandardMaterial({ color:0x00ccff })
	);
}

async function updatePlayers(){
	const data=await fetch("/map").then(r=>r.json());
	tributeUI.innerHTML="<b>Tributes</b><br>";
	const alive=new Set();

	for(const p of data){
		alive.add(p.id);
		if(!players.has(p.id)){
			const m=makePlayer();
			group.add(m);
			players.set(p.id,m);
		}
		const m=players.get(p.id);
		m.position.set(p.x,p.y,p.z);

		const d=document.createElement("div");
		d.className="name";
		d.textContent=p.name;
		d.onclick=()=>cam.follow=m;
		tributeUI.appendChild(d);
	}
	for(const [id,m] of players){
		if(!alive.has(id)){
			group.remove(m);
			players.delete(id);
		}
	}
}
setInterval(updatePlayers,200);

/* ================= COLLISION ================= */
const ray=new THREE.Raycaster();
function collide(pos){
	for(const m of arenaMeshes){
		ray.set(pos,new THREE.Vector3(0,-1,0));
		const hit=ray.intersectObject(m);
		if(hit.length && hit[0].distance<30){
			pos.y+=30-hit[0].distance;
		}
	}
}

/* ================= LOOP ================= */
let last=performance.now();
function animate(){
	requestAnimationFrame(animate);
	const dt=(performance.now()-last)/1000; last=performance.now();

	camera.rotation.order="YXZ";
	camera.rotation.y=cam.yaw;
	camera.rotation.x=cam.pitch;

	if(cam.follow){
		const target=cam.follow.position.clone();
		const offset=new THREE.Vector3(0,120,-280).applyEuler(camera.rotation);
		camera.position.lerp(target.clone().add(offset),0.08);
	}else{
		const dir=new THREE.Vector3();
		camera.getWorldDirection(dir);
		const right=new THREE.Vector3().crossVectors(dir,camera.up);

		const accel=new THREE.Vector3()
			.addScaledVector(dir,cam.input.f)
			.addScaledVector(right,cam.input.r)
			.addScaledVector(camera.up,cam.input.u)
			.normalize()
			.multiplyScalar(cam.accel*dt);

		cam.vel.add(accel);
		cam.vel.multiplyScalar(Math.exp(-cam.damping*dt));
		cam.vel.clampLength(0,cam.max);
		camera.position.addScaledVector(cam.vel,dt);
	}

	collide(camera.position);

	scene.traverse(o=>{
		if(o.material?.uniforms?.iTime)
			o.material.uniforms.iTime.value+=dt;
	});

	renderer.render(scene,camera);
}
animate();

/* ================= RESIZE ================= */
addEventListener("resize",()=>{
	camera.aspect=innerWidth/innerHeight;
	camera.updateProjectionMatrix();
	renderer.setSize(innerWidth,innerHeight);
});
</script>
</body>
</html>
