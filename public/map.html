<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Spectator Map</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<style>
html, body {
  margin: 0;
  width: 100%;
  height: 100%;
  overflow: hidden;
  font-family: system-ui, Segoe UI, sans-serif;
  background: radial-gradient(circle at 50% 15%, #160406, #020001);
  transition: background 0.3s;
}
body.light {
  background: radial-gradient(circle at 50% 15%, #eee, #aaa);
}

#sidebar {
  position: fixed;
  top: 0;
  left: 0;
  width: 280px;
  height: 100%;
  background: rgba(20,10,15,0.85);
  backdrop-filter: blur(14px);
  color: #ffe8ee;
  overflow-y: auto;
  transition: transform 0.3s;
  z-index: 10;
  padding: 16px;
}
body.light #sidebar {
  background: rgba(250,250,250,0.9);
  color: #111;
}
#sidebar.collapsed {
  transform: translateX(-280px);
}
#sidebar h2 { margin-top:0; }
#toggleSidebar {
  position: fixed;
  left: 280px;
  top: 16px;
  z-index: 20;
  background: #ff6b7a;
  color: white;
  border: none;
  padding: 8px 12px;
  cursor: pointer;
  border-radius: 8px;
}
body.light #toggleSidebar { background: #666; }

.name {
  padding: 6px 8px;
  border-radius: 6px;
  margin: 2px 0;
  cursor: pointer;
}
.name:hover { background: rgba(255,120,140,0.3); }

#settings { margin-top: 20px; }
</style>

<script type="importmap">
{
  "imports": {
    "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js"
  }
}
</script>
</head>

<body>
<div id="sidebar">
  <h2>Tributes</h2>
  <div id="tributeList"></div>

  <div id="settings">
    <h3>Settings</h3>
    <button id="toggleTheme">Toggle Dark/Light Mode</button>
  </div>
</div>
<button id="toggleSidebar">â˜°</button>

<script type="module">
import * as THREE from "three";
import { OBJLoader } from "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/loaders/OBJLoader.js";

/* ================= RENDERER ================= */
const renderer = new THREE.WebGLRenderer({ antialias:true });
renderer.setSize(innerWidth, innerHeight);
renderer.setPixelRatio(devicePixelRatio);
document.body.appendChild(renderer.domElement);

/* ================= SCENE ================= */
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(60, innerWidth/innerHeight, 1, 20000);
camera.position.set(0,1200,1800);

/* ================= LIGHT ================= */
scene.add(new THREE.AmbientLight(0xffffff,0.35));
const sun = new THREE.DirectionalLight(0xffc0cc,1.3);
sun.position.set(3000,6000,2000);
scene.add(sun);

/* ================= ARENA MESH ================= */
const arenaGroup = new THREE.Group();
scene.add(arenaGroup);

const floorShaderUniforms = { time: { value: 0 } };
let arenaMesh;

new OBJLoader().load("/arena.obj", obj=>{
  obj.traverse(n=>{
    if(n.isMesh){
      // Shader material with scanlines projected onto arena
      n.material = new THREE.ShaderMaterial({
        uniforms: floorShaderUniforms,
        vertexShader: `
          varying vec2 vUv;
          void main(){
            vUv = uv;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position,1.0);
          }
        `,
        fragmentShader: `
          precision highp float;
          varying vec2 vUv;
          uniform float time;
          void main(){
            vec3 col = vec3(0.35,0.07,0.1);
            float scan = sin(vUv.x * 100.0 + time*5.0)*0.03;
            col += scan;
            gl_FragColor = vec4(col,1.0);
          }
        `
      });
    }
  });
  obj.scale.setScalar(4);
  arenaGroup.add(obj);
  arenaMesh = obj;
});

/* ================= PLAYERS ================= */
const players = new Map();
let follow = null;

function makePlayer(){
  const g = new THREE.Group();
  const body = new THREE.Mesh(
    new THREE.SphereGeometry(10,24,24),
    new THREE.MeshStandardMaterial({ color:0xff6b7a, emissive:0xff2a40, emissiveIntensity:0.7 })
  );
  g.add(body);

  const dirLineMat = new THREE.LineBasicMaterial({ color:0xff6b7a, opacity:0.7, transparent:true });
  const points = [new THREE.Vector3(0,0,0), new THREE.Vector3(0,0,-80)];
  const dirLine = new THREE.Line(new THREE.BufferGeometry().setFromPoints(points), dirLineMat);
  dirLine.rotation.x = Math.PI/2;
  g.add(dirLine);
  g.userData.dirLine = dirLine;

  return g;
}

/* ================= UPDATE PLAYERS ================= */
async function updatePlayers(){
  const data = await fetch("/map").then(r=>r.json());
  const tributeList = document.getElementById("tributeList");
  tributeList.innerHTML = "";
  const alive = new Set();

  for(const p of data){
    alive.add(p.id);
    if(!players.has(p.id)){
      const m = makePlayer();
      scene.add(m);
      players.set(p.id, m);
    }
    const m = players.get(p.id);
    m.position.set(p.x, p.y+20, p.z);
    m.rotation.y = p.yaw;
    if(m.userData.dirLine) m.userData.dirLine.rotation.z = p.pitch;

    const d = document.createElement("div");
    d.className = "name";
    d.textContent = p.name;
    d.onclick = ()=> follow = m;
    tributeList.appendChild(d);
  }

  for(const [id, m] of players){
    if(!alive.has(id)){
      scene.remove(m);
      players.delete(id);
    }
  }
}
setInterval(updatePlayers,200);

/* ================= CAMERA CONTROLS ================= */
const cam = { yaw:0, pitch:0, velocity:new THREE.Vector3(), accel:2.4, damping:0.88, baseSpeed:18, boost:3.0 };
const keys = { w:false,a:false,s:false,d:false,shift:false };
let rotating=false;

renderer.domElement.addEventListener("mousedown",e=>{
  if(e.button===0){ rotating=true; renderer.domElement.requestPointerLock(); }
});
addEventListener("mouseup",()=>{ rotating=false; document.exitPointerLock(); });
addEventListener("mousemove",e=>{
  if(rotating && document.pointerLockElement){
    cam.yaw -= e.movementX*0.002;
    cam.pitch = Math.max(-1.4, Math.min(1.4, cam.pitch - e.movementY*0.002));
  }
});
addEventListener("keydown",e=>{
  if(e.code==="KeyW") keys.w=true;
  if(e.code==="KeyA") keys.a=true;
  if(e.code==="KeyS") keys.s=true;
  if(e.code==="KeyD") keys.d=true;
  if(e.code==="ShiftLeft") keys.shift=true;
  if("KeyWKeyAKeySKeyD".includes(e.code)) follow=null;
});
addEventListener("keyup",e=>{
  if(e.code==="KeyW") keys.w=false;
  if(e.code==="KeyA") keys.a=false;
  if(e.code==="KeyS") keys.s=false;
  if(e.code==="KeyD") keys.d=false;
  if(e.code==="ShiftLeft") keys.shift=false;
});

/* ================= LOOP ================= */
function animate(){
  requestAnimationFrame(animate);
  const delta = 0.016;

  camera.rotation.order="YXZ";
  camera.rotation.y = cam.yaw;
  camera.rotation.x = cam.pitch;

  const forward = new THREE.Vector3(0,0,-1).applyEuler(camera.rotation);
  const right = new THREE.Vector3(1,0,0).applyEuler(camera.rotation);
  let mult = cam.baseSpeed;
  if(keys.shift) mult *= cam.boost;
  if(keys.w) cam.velocity.addScaledVector(forward, cam.accel*mult);
  if(keys.s) cam.velocity.addScaledVector(forward, -cam.accel*mult);
  if(keys.a) cam.velocity.addScaledVector(right, -cam.accel*mult);
  if(keys.d) cam.velocity.addScaledVector(right, cam.accel*mult);

  cam.velocity.multiplyScalar(cam.damping);
  camera.position.add(cam.velocity);

  if(follow){
    const t = follow.position.clone();
    const off = new THREE.Vector3(0,140,-320).applyEuler(camera.rotation);
    camera.position.lerp(t.add(off),0.08);
    cam.velocity.set(0,0,0);
  }

  if(floorShaderUniforms.time) floorShaderUniforms.time.value = performance.now()*0.001;

  renderer.render(scene,camera);
}
animate();

/* ================= RESIZE ================= */
addEventListener("resize",()=>{
  renderer.setSize(innerWidth, innerHeight);
  camera.aspect = innerWidth/innerHeight;
  camera.updateProjectionMatrix();
});

/* ================= SIDEBAR ================= */
const sidebar = document.getElementById("sidebar");
document.getElementById("toggleSidebar").onclick = ()=> sidebar.classList.toggle("collapsed");

document.getElementById("toggleTheme").onclick = ()=>{
  document.body.classList.toggle("light");
};
</script>
</body>
</html>
