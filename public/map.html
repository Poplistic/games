<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Spectator Map</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<style>
html, body {
    margin: 0;
    width: 100%;
    height: 100%;
    overflow: hidden;
    background: #000;
    font-family: system-ui, Segoe UI, sans-serif;
}

/* ===== DARK BROADCAST UI ===== */
#ui {
    position: fixed;
    top: 16px;
    left: 16px;
    background: rgba(10,12,16,0.85);
    border-radius: 14px;
    padding: 12px 14px;
    box-shadow: 0 10px 30px rgba(0,0,0,0.6);
    z-index: 10;
    min-width: 180px;
    color: #f2f2f2;
}

.name {
    margin-top: 6px;
    padding: 6px 10px;
    border-radius: 10px;
    background: rgba(255,255,255,0.06);
    cursor: pointer;
    transition: background 0.15s;
}

.name:hover {
    background: rgba(255,255,255,0.12);
}

.name.selected {
    background: linear-gradient(90deg, #ff4d5e, #ff9aa5);
    color: #111;
    font-weight: 600;
}

canvas { display:block }
</style>

<script type="importmap">
{
  "imports": {
    "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js"
  }
}
</script>
</head>
<body>

<div id="ui"><b>Tributes</b></div>

<script type="module">
import * as THREE from "three";
import { OBJLoader } from "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/loaders/OBJLoader.js";

/* ================= RENDERER ================= */
const renderer = new THREE.WebGLRenderer({ antialias:true });
renderer.setSize(innerWidth, innerHeight);
renderer.setPixelRatio(devicePixelRatio);
renderer.outputColorSpace = THREE.SRGBColorSpace;
renderer.toneMapping = THREE.ACESFilmicToneMapping;
renderer.toneMappingExposure = 1.05;
document.body.appendChild(renderer.domElement);

/* ================= SCENE ================= */
const scene = new THREE.Scene();

/* ================= SKY (REALISTIC GRADIENT) ================= */
const skyGeo = new THREE.SphereGeometry(12000, 32, 32);
const skyMat = new THREE.ShaderMaterial({
    side: THREE.BackSide,
    uniforms: {
        top:    { value: new THREE.Color(0x87b6e6) },
        bottom: { value: new THREE.Color(0xf6e7c1) }
    },
    vertexShader: `
        varying vec3 vPos;
        void main(){
            vPos = position;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position,1.0);
        }
    `,
    fragmentShader: `
        varying vec3 vPos;
        uniform vec3 top;
        uniform vec3 bottom;
        void main(){
            float h = normalize(vPos).y * 0.5 + 0.5;
            gl_FragColor = vec4(mix(bottom, top, h), 1.0);
        }
    `
});
scene.add(new THREE.Mesh(skyGeo, skyMat));

/* ================= CAMERA ================= */
const camera = new THREE.PerspectiveCamera(60, innerWidth/innerHeight, 1, 20000);
camera.position.set(0, 900, 1700);

/* ================= LIGHTING ================= */
scene.add(new THREE.AmbientLight(0xffffff, 0.75));

const sun = new THREE.DirectionalLight(0xfff2d6, 1.0);
sun.position.set(6000, 7000, 3000);
scene.add(sun);

/* ================= FLOOR (SANDY) ================= */
const floor = new THREE.Mesh(
    new THREE.PlaneGeometry(7000, 7000),
    new THREE.MeshStandardMaterial({
        color: 0xe8d3a2,
        roughness: 0.95
    })
);
floor.rotation.x = -Math.PI / 2;
scene.add(floor);

/* ================= GRID (SUBTLE) ================= */
const grid = new THREE.GridHelper(7000, 70, 0xcbb98b, 0xe6dab8);
grid.material.transparent = true;
grid.material.opacity = 0.35;
scene.add(grid);

/* ================= ARENA (SAND + OUTLINE) ================= */
const loader = new OBJLoader();
loader.load("/arena.obj", obj => {
    obj.traverse(n => {
        if (n.isMesh) {
            n.material = new THREE.MeshStandardMaterial({
                color: 0xe6cfa0,
                roughness: 0.9
            });

            const edges = new THREE.EdgesGeometry(n.geometry, 20);
            n.add(new THREE.LineSegments(
                edges,
                new THREE.LineBasicMaterial({
                    color: 0x5a4a2f,
                    transparent: true,
                    opacity: 0.8
                })
            ));
        }
    });
    obj.scale.setScalar(10);
    obj.rotation.y = Math.PI;
    scene.add(obj);
});

/* ================= PLAYERS / HALOS / LABELS ================= */
const players = new Map();
const halos = new Map();
const labels = new Map();
let selectedId = null;
let orbitAngle = 0;

const ui = document.getElementById("ui");
const texLoader = new THREE.TextureLoader();

/* --- halo texture --- */
function makeHaloTexture(){
    const c = document.createElement("canvas");
    c.width = c.height = 256;
    const g = c.getContext("2d");

    const grad = g.createRadialGradient(128,128,50,128,128,120);
    grad.addColorStop(0,"rgba(255,255,255,0)");
    grad.addColorStop(0.6,"rgba(255,80,100,0.45)");
    grad.addColorStop(1,"rgba(255,255,255,0)");

    g.fillStyle = grad;
    g.fillRect(0,0,256,256);
    return new THREE.CanvasTexture(c);
}

const haloTexture = makeHaloTexture();

function makeHalo(){
    const mat = new THREE.MeshBasicMaterial({
        map: haloTexture,
        transparent: true,
        depthWrite: false,
        opacity: 0.35
    });
    const mesh = new THREE.Mesh(new THREE.PlaneGeometry(240,240), mat);
    mesh.rotation.x = -Math.PI/2;
    scene.add(mesh);
    return mesh;
}

/* --- nameplate --- */
function makeLabel(name){
    const c = document.createElement("canvas");
    c.width = 256;
    c.height = 64;
    const g = c.getContext("2d");

    g.fillStyle = "rgba(0,0,0,0.75)";
    g.fillRect(0,0,256,64);
    g.fillStyle = "white";
    g.font = "bold 28px system-ui";
    g.textAlign = "center";
    g.textBaseline = "middle";
    g.fillText(name,128,34);

    const tex = new THREE.CanvasTexture(c);
    const s = new THREE.Sprite(new THREE.SpriteMaterial({
        map: tex,
        transparent: true,
        depthTest: false
    }));
    s.scale.set(200,50,1);
    scene.add(s);
    return s;
}

function makePlayer(p){
    const sprite = new THREE.Sprite(new THREE.SpriteMaterial({
        map: texLoader.load(`/bust/${p.id}`),
        transparent: true,
        depthTest:false
    }));
    sprite.scale.set(90,90,1);
    scene.add(sprite);

    halos.set(p.id, makeHalo());
    labels.set(p.id, makeLabel(p.name));
    return sprite;
}

/* ================= DATA ================= */
async function updatePlayers(){
    let data;
    try {
        const r = await fetch("/map");
        if(!r.ok) return;
        data = await r.json();
    } catch { return; }

    ui.innerHTML = "<b>Tributes</b>";
    const alive = new Set();

    for(const p of data){
        alive.add(p.id);
        if(!players.has(p.id)){
            players.set(p.id, makePlayer(p));
        }

        players.get(p.id).position.set(p.x, p.y+90, p.z);
        halos.get(p.id).position.set(p.x, 2, p.z);
        labels.get(p.id).position.set(p.x, p.y+170, p.z);

        const d = document.createElement("div");
        d.className = "name" + (p.id === selectedId ? " selected" : "");
        d.textContent = p.name;
        d.onclick = () => selectedId = selectedId === p.id ? null : p.id;
        ui.appendChild(d);
    }

    for(const [id,p] of players){
        if(!alive.has(id)){
            scene.remove(p);
            scene.remove(halos.get(id));
            scene.remove(labels.get(id));
            players.delete(id);
            halos.delete(id);
            labels.delete(id);
        }
    }
}
setInterval(updatePlayers, 250);

/* ================= LOOP ================= */
function animate(){
    requestAnimationFrame(animate);

    if(selectedId && players.has(selectedId)){
        orbitAngle += 0.002;
        const target = players.get(selectedId).position;
        const radius = 900;
        const height = 700;

        const desired = new THREE.Vector3(
            target.x + Math.cos(orbitAngle)*radius,
            target.y + height,
            target.z + Math.sin(orbitAngle)*radius
        );

        camera.position.lerp(desired, 0.04);
        camera.lookAt(target);
    }

    for(const [,p] of players){
        p.quaternion.copy(camera.quaternion);
    }
    for(const [,l] of labels){
        l.quaternion.copy(camera.quaternion);
    }

    renderer.render(scene, camera);
}
animate();

/* ================= RESIZE ================= */
addEventListener("resize", ()=>{
    renderer.setSize(innerWidth, innerHeight);
    camera.aspect = innerWidth/innerHeight;
    camera.updateProjectionMatrix();
});
</script>
</body>
</html>
