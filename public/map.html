<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Spectator Map</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<style>
	body {
		margin:0;
		overflow:hidden;
		background:black;
	}
	canvas { display:block }

	.ui {
		position:absolute;
		color:white;
		font-family:system-ui, sans-serif;
		background:rgba(20,20,20,.65);
		backdrop-filter: blur(6px);
		border:1px solid rgba(255,255,255,.1);
		border-radius:8px;
		padding:8px 10px;
		font-size:12px;
		box-shadow:0 0 20px rgba(0,0,0,.6);
	}

	input {
		background:#111;
		color:white;
		border:1px solid #333;
		border-radius:4px;
		padding:4px;
	}
</style>

<script type="importmap">
{
  "imports": {
    "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js"
  }
}
</script>
</head>

<body>

<script src="https://cdn.socket.io/4.7.5/socket.io.min.js"></script>

<script type="module">
import * as THREE from "three";
import { OrbitControls } from "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/controls/OrbitControls.js";
import { OBJLoader } from "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/loaders/OBJLoader.js";

/* ======================
   RENDERER
====================== */
const renderer = new THREE.WebGLRenderer({ antialias:true });
renderer.setSize(innerWidth, innerHeight);
renderer.setPixelRatio(devicePixelRatio);
renderer.outputColorSpace = THREE.SRGBColorSpace;
renderer.toneMapping = THREE.ACESFilmicToneMapping;
renderer.toneMappingExposure = 1.1;
renderer.shadowMap.enabled = true;
renderer.shadowMap.type = THREE.PCFSoftShadowMap;
document.body.appendChild(renderer.domElement);

/* ======================
   SCENE + FOG
====================== */
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x050508);
scene.fog = new THREE.FogExp2(0x050508, 0.000045);

/* ======================
   CAMERA
====================== */
const camera = new THREE.PerspectiveCamera(60, innerWidth/innerHeight, 1, 20000);
camera.position.set(2000,2000,2000);

/* ======================
   CONTROLS
====================== */
const controls = new OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;

/* ======================
   LIGHTING
====================== */
scene.add(new THREE.AmbientLight(0xffffff, 0.35));

const sun = new THREE.DirectionalLight(0xffffff, 1.1);
sun.position.set(3000,6000,2000);
sun.castShadow = true;
sun.shadow.mapSize.set(2048,2048);
sun.shadow.camera.left = -6000;
sun.shadow.camera.right = 6000;
sun.shadow.camera.top = 6000;
sun.shadow.camera.bottom = -6000;
scene.add(sun);

scene.add(new THREE.DirectionalLight(0x88aaff, 0.4));

/* ======================
   GROUPS
====================== */
const playerGroup = new THREE.Group();
const spectatorGroup = new THREE.Group();
scene.add(playerGroup, spectatorGroup);

/* ======================
   LOAD ARENA
====================== */
const loader = new OBJLoader();
let terrainMesh = null;

loader.load("arena.obj", obj=>{
	obj.traverse(m=>{
		if (m.isMesh) {
			m.castShadow = true;
			m.receiveShadow = true;
			m.material.side = THREE.DoubleSide;
		}
	});
	obj.scale.set(1,1,1);
	scene.add(obj);
	terrainMesh = obj;
});

/* ======================
   UI
====================== */
const tributeUI = ui("10px","10px");
const killUI = ui("10px",null,"10px");
const chatUI = ui(null,"10px",null,"10px");

chatUI.innerHTML = `
	<div id="log" style="height:120px;overflow:auto"></div>
	<input id="input" placeholder="chat" style="width:100%">
`;

function ui(t,l,r,b){
	const d=document.createElement("div");
	d.className="ui";
	if(t)d.style.top=t;
	if(l)d.style.left=l;
	if(r)d.style.right=r;
	if(b)d.style.bottom=b;
	document.body.appendChild(d);
	return d;
}

/* ======================
   STATE
====================== */
let tracked=null,lastTrackedPos=null,trackedVelocity=0;
let followMode="behind";
const players=new Map();

/* ======================
   PLAYER
====================== */
function makePlayer(){
	const dot=new THREE.Mesh(
		new THREE.SphereGeometry(10,16,16),
		new THREE.MeshStandardMaterial({
			color:0x00ff88,
			emissive:0x003322,
			emissiveIntensity:0.6
		})
	);
	dot.castShadow=true;

	const hit=new THREE.Mesh(
		new THREE.SphereGeometry(45),
		new THREE.MeshBasicMaterial({transparent:true,opacity:0})
	);
	hit.userData.isHitbox=true;
	dot.add(hit);

	const arrow=new THREE.ArrowHelper(
		new THREE.Vector3(0,0,1),
		new THREE.Vector3(),
		90,
		0xffff00
	);
	dot.add(arrow);
	dot.userData.arrow=arrow;

	const halo=new THREE.Mesh(
		new THREE.RingGeometry(14,22,32),
		new THREE.MeshBasicMaterial({
			color:0x00ffcc,
			transparent:true,
			opacity:0,
			side:THREE.DoubleSide
		})
	);
	halo.rotation.x=-Math.PI/2;
	halo.userData.isHalo=true;
	dot.add(halo);

	return dot;
}

/* ======================
   PLAYER UPDATE
====================== */
const raycaster=new THREE.Raycaster();
const rayOrigin=new THREE.Vector3();
const rayDown=new THREE.Vector3(0,-1,0);
const targetPos=new THREE.Vector3();
const lookDir=new THREE.Vector3();

async function updatePlayers(){
	const data=await fetch("/map").then(r=>r.json());
	tributeUI.innerHTML="<b>Tributes</b><br>"+data.map(p=>p.name).join("<br>");
	const active=new Set();

	for(const p of data){
		active.add(p.id);
		if(!players.has(p.id)){
			const m=makePlayer();
			playerGroup.add(m);
			players.set(p.id,m);
		}
		const m=players.get(p.id);
		let y=p.y??6;

		if(terrainMesh){
			rayOrigin.set(p.x,5000,p.z);
			raycaster.set(rayOrigin,rayDown);
			const hit=raycaster.intersectObject(terrainMesh,true);
			if(hit[0]) y=hit[0].point.y+6;
		}

		targetPos.set(p.x,y,p.z);
		m.position.lerp(targetPos,0.35);

		if(p.lookX!==undefined){
			lookDir.set(p.lookX,0,p.lookZ).normalize();
			m.userData.arrow.setDirection(lookDir);
		}
	}

	for(const [id,m] of players){
		if(!active.has(id)){
			playerGroup.remove(m);
			players.delete(id);
		}
	}
}
setInterval(updatePlayers,200);

/* ======================
   TRACKING
====================== */
addEventListener("pointerdown",e=>{
	const mouse=new THREE.Vector2(
		e.clientX/innerWidth*2-1,
		-(e.clientY/innerHeight)*2+1
	);
	raycaster.setFromCamera(mouse,camera);
	const hit=raycaster.intersectObjects(playerGroup.children,true)
		.find(h=>h.object.userData.isHitbox);
	if(hit) tracked=hit.object.parent;
});

/* ======================
   CINEMATIC FOLLOW
====================== */
const camVel=new THREE.Vector3();
const camTarget=new THREE.Vector3();

function follow(){
	if(!tracked||followMode==="free")return;

	if(lastTrackedPos)
		trackedVelocity=tracked.position.distanceTo(lastTrackedPos);
	lastTrackedPos=tracked.position.clone();

	const speed=THREE.MathUtils.clamp(trackedVelocity*6,0,1400);
	const offset=followMode==="behind"
		?new THREE.Vector3(0,320+speed*0.25,780+speed)
		:new THREE.Vector3(0,1400+speed,0);

	camTarget.copy(tracked.position).add(offset);
	camVel.subVectors(camTarget,camera.position).multiplyScalar(0.06);
	camera.position.add(camVel);

	camera.lookAt(camera.position.clone().lerp(tracked.position,0.12));
}

/* ======================
   GLOW UPDATE
====================== */
function updateGlow(t){
	for(const m of playerGroup.children){
		const halo=m.children.find(c=>c.userData.isHalo);
		if(!halo)continue;

		if(m===tracked){
			halo.material.opacity=0.5+Math.sin(t*0.006)*0.3;
			m.material.emissiveIntensity=1.2;
		}else{
			halo.material.opacity=0;
			m.material.emissiveIntensity=0.5;
		}
	}
}

/* ======================
   FOG HEIGHT BIAS
====================== */
function updateFog(){
	scene.fog.density=0.000045*
		THREE.MathUtils.clamp(camera.position.y/4000,0.2,1.4);
}

/* ======================
   LOOP
====================== */
function animate(){
	requestAnimationFrame(animate);
	follow();
	updateGlow(performance.now());
	updateFog();
	controls.update();
	renderer.render(scene,camera);
}
animate();
</script>
</body>
</html>
