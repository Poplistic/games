<script type="module">
import * as THREE from "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js";
import { OrbitControls } from "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/controls/OrbitControls.js";
import { Sky } from "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/objects/Sky.js";

/* ======================
   CONFIG
====================== */

const DOT_RADIUS = 5;
const HITBOX_RADIUS = 40;
const PREDICTION_TIME = 0.15; // seconds
const TRACK_ZOOM = 900;
const FREE_ZOOM = 2600;

/* ======================
   RENDERER
====================== */

const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(innerWidth, innerHeight);
renderer.setPixelRatio(devicePixelRatio);
renderer.outputColorSpace = THREE.SRGBColorSpace;
renderer.toneMapping = THREE.ACESFilmicToneMapping;
renderer.toneMappingExposure = 1.1;
document.body.appendChild(renderer.domElement);

/* ======================
   SCENE / CAMERA
====================== */

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(60, innerWidth / innerHeight, 1, 10000);
camera.position.set(2000, 1600, 2000);

const controls = new OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;

/* ======================
   SKY / LIGHTS
====================== */

const sky = new Sky();
sky.scale.setScalar(10000);
scene.add(sky);

const sun = new THREE.Vector3();
sky.material.uniforms.turbidity.value = 10;
sky.material.uniforms.rayleigh.value = 2;
sky.material.uniforms.mieCoefficient.value = 0.005;
sky.material.uniforms.mieDirectionalG.value = 0.8;

const dirLight = new THREE.DirectionalLight(0xffffff, 3);
scene.add(dirLight);
scene.add(new THREE.AmbientLight(0x404060, 0.4));

/* ======================
   PLAYER MARKERS
====================== */

const playerGroup = new THREE.Group();
scene.add(playerGroup);

function makeMarker() {
	const g = new THREE.Group();

	// Dot
	const dot = new THREE.Mesh(
		new THREE.SphereGeometry(DOT_RADIUS, 16, 16),
		new THREE.MeshBasicMaterial({ color: 0x00ff00 })
	);
	g.add(dot);

	// Highlight ring
	const ring = new THREE.Mesh(
		new THREE.RingGeometry(10, 14, 32),
		new THREE.MeshBasicMaterial({ color: 0x00ffff, transparent: true, opacity: 0 })
	);
	ring.rotation.x = -Math.PI / 2;
	g.add(ring);

	// Direction arrow
	const arrow = new THREE.ArrowHelper(
		new THREE.Vector3(0, 0, 1),
		new THREE.Vector3(0, 0, 0),
		80,
		0x00ffff
	);
	arrow.visible = false;
	g.add(arrow);

	// Hitbox
	const hitbox = new THREE.Mesh(
		new THREE.SphereGeometry(HITBOX_RADIUS, 16, 16),
		new THREE.MeshBasicMaterial({ transparent: true, opacity: 0 })
	);
	g.add(hitbox);

	g.userData = {
		dot,
		ring,
		arrow,
		hitbox,
		lastPos: null,
		velocity: new THREE.Vector3()
	};

	return g;
}

const markers = new Map();
let tracked = null;

/* ======================
   UPDATE PLAYERS
====================== */

function updatePlayers(list) {
	const seen = new Set();

	for (const p of list) {
		seen.add(p.id);

		if (!markers.has(p.id)) {
			const m = makeMarker();
			playerGroup.add(m);
			markers.set(p.id, m);
		}

		const m = markers.get(p.id);
		const now = performance.now() / 1000;

		const pos = new THREE.Vector3(p.x, 20, p.z);

		if (m.userData.lastPos) {
			const dt = Math.max(now - m.userData.lastTime, 0.016);
			m.userData.velocity.copy(pos).sub(m.userData.lastPos).divideScalar(dt);
		}

		m.userData.lastPos = pos.clone();
		m.userData.lastTime = now;

		const predicted = pos.clone().add(
			m.userData.velocity.clone().multiplyScalar(PREDICTION_TIME)
		);

		m.position.lerp(predicted, 0.5);

		// Direction arrow
		if (p.lookX !== undefined) {
			m.userData.arrow.setDirection(
				new THREE.Vector3(p.lookX, 0, p.lookZ).normalize()
			);
		}
	}

	for (const [id, m] of markers) {
		if (!seen.has(id)) {
			playerGroup.remove(m);
			markers.delete(id);
		}
	}
}

/* ======================
   FETCH LOOP
====================== */

let lighting = null;

setInterval(async () => {
	updatePlayers(await fetch("/map").then(r => r.json()));
	lighting = await fetch("/lighting").then(r => r.json());
}, 200);

/* ======================
   CLICK / TOUCH
====================== */

const raycaster = new THREE.Raycaster();
const pointer = new THREE.Vector2();

function pick(event) {
	const rect = renderer.domElement.getBoundingClientRect();
	const e = event.touches ? event.touches[0] : event;

	pointer.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
	pointer.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;

	raycaster.setFromCamera(pointer, camera);

	const hitboxes = [];
	markers.forEach(m => hitboxes.push(m.userData.hitbox));

	const hits = raycaster.intersectObjects(hitboxes);

	if (hits.length) {
		tracked = hits[0].object.parent;
	} else {
		tracked = null;
	}
}

renderer.domElement.addEventListener("click", pick);
renderer.domElement.addEventListener("touchstart", pick, { passive: true });

/* ======================
   ANIMATION LOOP
====================== */

function animate() {
	requestAnimationFrame(animate);

	if (lighting) {
		sun.set(...lighting.sunDirection);
		sky.material.uniforms.sunPosition.value.copy(sun.multiplyScalar(5000));
		dirLight.position.copy(sun);
		dirLight.intensity = lighting.brightness * 1.2;
	}

	// Marker visuals
	markers.forEach(m => {
		const selected = m === tracked;
		m.userData.dot.material.color.set(selected ? 0x00ffff : 0x00ff00);
		m.userData.arrow.visible = selected;

		m.userData.ring.material.opacity = selected
			? 0.5 + Math.sin(performance.now() * 0.005) * 0.25
			: 0;
	});

	// Camera tracking + zoom
	if (tracked) {
		controls.target.lerp(tracked.position, 0.1);
		camera.position.lerp(
			tracked.position.clone().add(new THREE.Vector3(0, TRACK_ZOOM, TRACK_ZOOM)),
			0.05
		);
	} else {
		camera.position.lerp(
			new THREE.Vector3(2000, FREE_ZOOM, 2000),
			0.02
		);
	}

	controls.update();
	renderer.render(scene, camera);
}

animate();
</script>
