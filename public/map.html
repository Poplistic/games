<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Spectator Map</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<style>
	body { margin:0; overflow:hidden; background:black; }
	canvas { display:block }

	.ui {
		position:absolute;
		color:white;
		font-family:system-ui,sans-serif;
		background:rgba(20,20,20,.65);
		backdrop-filter: blur(6px);
		border:1px solid rgba(255,255,255,.1);
		border-radius:8px;
		padding:8px 10px;
		font-size:12px;
		box-shadow:0 0 20px rgba(0,0,0,.6);
	}

	input {
		width:100%;
		box-sizing:border-box;
		background:#111;
		color:white;
		border:1px solid #333;
		border-radius:4px;
		padding:4px;
	}

	#log div { transition:opacity 1.2s ease }
	#log.fade div { opacity:0 }
</style>

<script type="importmap">
{
  "imports": {
    "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js"
  }
}
</script>
</head>

<body>
<script src="https://cdn.socket.io/4.7.5/socket.io.min.js"></script>

<script type="module">
import * as THREE from "three";
import { OrbitControls } from "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/controls/OrbitControls.js";
import { OBJLoader } from "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/loaders/OBJLoader.js";

/* ======================
   BASIC SETUP
====================== */
const renderer = new THREE.WebGLRenderer({ antialias:true });
renderer.setSize(innerWidth, innerHeight);
renderer.setPixelRatio(devicePixelRatio);
renderer.shadowMap.enabled = true;
document.body.appendChild(renderer.domElement);

const scene = new THREE.Scene();
scene.background = new THREE.Color(0x050508);
scene.fog = new THREE.FogExp2(0x050508, 0.000045);

const camera = new THREE.PerspectiveCamera(60, innerWidth/innerHeight, 1, 20000);
camera.position.set(2000,2000,2000);

const controls = new OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;

/* ======================
   LIGHTING
====================== */
scene.add(new THREE.AmbientLight(0xffffff, 0.35));
const sun = new THREE.DirectionalLight(0xffffff, 1.1);
sun.position.set(3000,6000,2000);
sun.castShadow = true;
scene.add(sun);

/* ======================
   GROUP
====================== */
const playerGroup = new THREE.Group();
scene.add(playerGroup);

/* ======================
   LOAD ARENA
====================== */
let terrainMesh = null;
new OBJLoader().load("arena.obj", obj=>{
	obj.traverse(m=>{
		if(m.isMesh){
			m.castShadow = true;
			m.receiveShadow = true;
		}
	});
	scene.add(obj);
	terrainMesh = obj;
});

/* ======================
   UI
====================== */
function ui(t,l,r,b){
	const d=document.createElement("div");
	d.className="ui";
	if(t)d.style.top=t;
	if(l)d.style.left=l;
	if(r)d.style.right=r;
	if(b)d.style.bottom=b;
	document.body.appendChild(d);
	return d;
}

const tributeUI = ui("10px","10px");
const chatUI = ui(null,"10px",null,"10px");

chatUI.innerHTML = `
	<div id="log" style="height:120px;overflow:auto;margin-bottom:6px"></div>
	<input id="input" placeholder="chat">
`;

/* ======================
   CHAT (ONLY PUBLIC FEATURE)
====================== */
const socket = io();
let lastChatTime = 0;
let chatFadeTimer = null;

function resetChatFade(){
	const log = document.getElementById("log");
	log.classList.remove("fade");
	clearTimeout(chatFadeTimer);
	chatFadeTimer = setTimeout(()=>log.classList.add("fade"),8000);
}

document.getElementById("input").addEventListener("keydown",e=>{
	if(e.key!=="Enter"||!e.target.value) return;
	const now = performance.now();
	if(now-lastChatTime < 1200) return;
	lastChatTime = now;
	socket.emit("chat:send", e.target.value);
	e.target.value="";
	resetChatFade();
});

socket.on("chat:msg",m=>{
	const log = document.getElementById("log");
	log.innerHTML += `<div><b>${m.from}:</b> ${m.msg}</div>`;
	log.scrollTop = log.scrollHeight;
	resetChatFade();
});

/* ======================
   NAME TAG
====================== */
function makeTextSprite(text,color){
	const c=document.createElement("canvas");
	c.width=128; c.height=64;
	const x=c.getContext("2d");
	x.fillStyle="rgba(0,0,0,.6)";
	x.fillRect(0,0,128,64);
	x.fillStyle=color;
	x.font="28px system-ui";
	x.textAlign="center";
	x.textBaseline="middle";
	x.fillText(text,64,32);
	const t=new THREE.CanvasTexture(c);
	const s=new THREE.Sprite(new THREE.SpriteMaterial({map:t,transparent:true}));
	s.scale.set(80,40,1);
	return s;
}

/* ======================
   PLAYER CREATION
====================== */
const players = new Map();

function makePlayer(name){
	const m = new THREE.Mesh(
		new THREE.SphereGeometry(10,16,16),
		new THREE.MeshStandardMaterial({ color:0x00ff00 })
	);

	/* Name */
	const tag = makeTextSprite(name,"#fff");
	tag.position.y = 80;
	m.add(tag);
	m.userData.tag = tag;

	/* 3D Direction Arrow */
	const arrowGeo = new THREE.ConeGeometry(6, 24, 4);
	arrowGeo.rotateX(Math.PI / 2); // point forward

	const arrowMat = new THREE.MeshStandardMaterial({
		color: 0xffff00,
		emissive: 0x222200
	});

	const arrow = new THREE.Mesh(arrowGeo, arrowMat);
	arrow.position.y = 32;
	arrow.castShadow = true;

	m.add(arrow);

	m.userData.arrow = arrow;
	m.userData.arrowAngle = 0;
	m.userData.arrowTarget = 0;


	return m;
}

/* ======================
   UPDATE PLAYERS
====================== */
const ray = new THREE.Raycaster();
const down = new THREE.Vector3(0,-1,0);
const tmp = new THREE.Vector3();
const look = new THREE.Vector3();

async function updatePlayers(){
	const data = await fetch("/map").then(r=>r.json());
	tributeUI.innerHTML="<b>Tributes</b><br>"+data.map(p=>p.name).join("<br>");
	const active = new Set();

	for(const p of data){
		active.add(p.id);
		if(!players.has(p.id)){
			const m = makePlayer(p.name);
			playerGroup.add(m);
			players.set(p.id,m);
		}

		const m = players.get(p.id);

		/* Smooth terrain snap */
		tmp.set(p.x,5000,p.z);
		ray.set(tmp,down);
		const hit = terrainMesh ? ray.intersectObject(terrainMesh,true)[0] : null;
		const targetY = hit ? hit.point.y + 6 : 6;
		m.position.x = p.x;
		m.position.z = p.z;
		m.position.y = THREE.MathUtils.lerp(m.position.y, targetY, 0.25);

		/* Health color */
		const hp = p.health ?? 100;
		if(hp > 66) m.material.color.set(0x00ff00);
		else if(hp > 33) m.material.color.set(0xffaa00);
		else m.material.color.set(0xff0000);

		/* Arrow target angle */
		if(p.lookX !== undefined){
			look.set(p.lookX,0,p.lookZ);
			if(look.lengthSq()>0.001){
				m.userData.arrowTarget = -Math.atan2(look.x, look.z);
			}
		}
	}

	for(const [id,m] of players){
		if(!active.has(id)){
			playerGroup.remove(m);
			players.delete(id);
		}
	}
}
setInterval(updatePlayers,200);

/* ======================
   LOOP
====================== */
function animate(){
	requestAnimationFrame(animate);

	/* Smooth arrow interpolation + billboard */
	for(const m of playerGroup.children){
		const a = m.userData;
		a.arrowAngle = THREE.MathUtils.lerp(
			a.arrowAngle,
			a.arrowTarget,
			0.18
		);
		a.arrow.rotation.y = a.arrowAngle;


		m.children.forEach(c=>{
		});
	}

	controls.update();
	renderer.render(scene,camera);
}
animate();
</script>
</body>
</html>
