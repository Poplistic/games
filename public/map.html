<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Hunger Games Arena â€“ Volumetric</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<style>
	body { margin: 0; overflow: hidden; background: black; }
	.label {
		position: absolute;
		color: #fff;
		font-size: 12px;
		pointer-events: none;
		transform: translate(-50%, -50%);
		text-shadow: 0 0 6px red;
	}
</style>

<script type="importmap">
{
  "imports": {
    "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js"
  }
}
</script>
</head>

<body>

<script type="module">
import * as THREE from "three";
import { OrbitControls } from "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/controls/OrbitControls.js";
import { OBJLoader } from "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/loaders/OBJLoader.js";

/* ======================
   RENDERER
====================== */

const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(innerWidth, innerHeight);
renderer.setPixelRatio(devicePixelRatio);
renderer.autoClear = false;
document.body.appendChild(renderer.domElement);

/* ======================
   SCENE / CAMERA
====================== */

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(60, innerWidth / innerHeight, 1, 8000);
camera.position.set(0, 900, 1400);

/* ======================
   CONTROLS
====================== */

const controls = new OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;

/* ======================
   LIGHTING
====================== */

scene.add(new THREE.AmbientLight(0x555555));
const sun = new THREE.DirectionalLight(0xffffff, 1.2);
sun.position.set(800, 1500, 600);
scene.add(sun);

/* ======================
   ARENA
====================== */

new OBJLoader().load("./arena.obj", obj => {
	obj.traverse(m => {
		if (m.isMesh) {
			m.material = new THREE.MeshStandardMaterial({
				color: 0x1a1a1a,
				roughness: 0.9
			});
		}
	});
	scene.add(obj);
});

/* ======================
   PLAYER MARKERS (REAL DATA)
====================== */

const markers = new Map();
const MAX_PLAYERS = 32;
const playerUniforms = Array(MAX_PLAYERS).fill().map(() => new THREE.Vector3());

async function updatePlayers() {
	const res = await fetch("/map");
	const players = await res.json();

	players.forEach((p, i) => {
		if (!markers.has(p.userId)) {
			const m = new THREE.Mesh(
				new THREE.SphereGeometry(10, 16, 16),
				new THREE.MeshBasicMaterial({ color: 0xff3333 })
			);
			scene.add(m);
			markers.set(p.userId, m);
		}

		const m = markers.get(p.userId);
		m.position.set(p.x, 15, p.z);

		if (i < MAX_PLAYERS) {
			playerUniforms[i].set(p.x, 0.0, p.z);
		}
	});
}
setInterval(updatePlayers, 250);

/* ======================
   PROJECTION SHADER (PLAYERS INJECTED)
====================== */

const projectionMaterial = new THREE.ShaderMaterial({
	uniforms: {
		uTime: { value: 0 },
		uPlayers: { value: playerUniforms },
		uPlayerCount: { value: 0 }
	},
	vertexShader: `
		void main() {
			gl_Position = vec4(position, 1.0);
		}
	`,
	fragmentShader: `
		uniform float uTime;
		uniform vec3 uPlayers[32];
		uniform int uPlayerCount;

		float beacon(vec2 uv, vec2 p) {
			float d = length(uv - p);
			return exp(-d * 40.0);
		}

		void main() {
			vec2 uv = gl_FragCoord.xy / vec2(${innerWidth.toFixed(1)}, ${innerHeight.toFixed(1)});
			vec3 col = vec3(0.0);

			for (int i = 0; i < 32; i++) {
				vec2 p = uPlayers[i].xz * 0.0005 + 0.5;
				col += vec3(0.8, 0.2, 0.2) * beacon(uv, p);
			}

			col *= 0.6;
			gl_FragColor = vec4(col, 0.6);
		}
	`,
	transparent: true,
	depthWrite: false
});

/* ======================
   TRUE VOLUMETRIC LIGHT RAYS
====================== */

const volumetricMaterial = new THREE.ShaderMaterial({
	uniforms: {
		uTime: { value: 0 }
	},
	vertexShader: `
		void main() {
			gl_Position = vec4(position, 1.0);
		}
	`,
	fragmentShader: `
		uniform float uTime;

		void main() {
			vec2 uv = gl_FragCoord.xy / vec2(${innerWidth.toFixed(1)}, ${innerHeight.toFixed(1)});
			vec2 p = uv * 2.0 - 1.0;

			float t = 0.0;
			float density = 0.0;

			for (int i = 0; i < 48; i++) {
				vec3 pos = vec3(p * t, t * 2.0);
				float d = length(pos.xz);
				density += exp(-d * 2.0) * 0.02;
				t += 0.05;
			}

			vec3 col = vec3(0.2, 0.5, 1.0) * density;
			gl_FragColor = vec4(col, density);
		}
	`,
	transparent: true,
	blending: THREE.AdditiveBlending,
	depthWrite: false
});

/* ======================
   OVERLAY SCENES
====================== */

const overlayCam = new THREE.OrthographicCamera(-1,1,1,-1,0,1);

const projectionScene = new THREE.Scene();
projectionScene.add(new THREE.Mesh(
	new THREE.PlaneGeometry(2,2),
	projectionMaterial
));

const volumetricScene = new THREE.Scene();
volumetricScene.add(new THREE.Mesh(
	new THREE.PlaneGeometry(2,2),
	volumetricMaterial
));

/* ======================
   ANIMATE
====================== */

function animate() {
	const t = performance.now() * 0.001;
	projectionMaterial.uniforms.uTime.value = t;
	volumetricMaterial.uniforms.uTime.value = t;

	controls.update();

	renderer.clear();
	renderer.render(scene, camera);                 // arena + markers
	renderer.render(projectionScene, overlayCam);  // projection
	renderer.render(volumetricScene, overlayCam);  // volumetric rays
}
renderer.setAnimationLoop(animate);

/* ======================
   RESIZE
====================== */

window.addEventListener("resize", () => {
	camera.aspect = innerWidth / innerHeight;
	camera.updateProjectionMatrix();
	renderer.setSize(innerWidth, innerHeight);
});
</script>

</body>
</html>
