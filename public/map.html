<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Digital Arena Projection</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">

<style>
	body {
		margin: 0;
		overflow: hidden;
		background: black;
	}
</style>

<script type="importmap">
{
  "imports": {
    "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js"
  }
}
</script>
</head>

<body>

<script type="module">
import * as THREE from "three";
import { OrbitControls } from "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/controls/OrbitControls.js";
import { OBJLoader } from "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/loaders/OBJLoader.js";

/* ======================
   RENDERER
====================== */

const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(innerWidth, innerHeight);
renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
renderer.outputColorSpace = THREE.SRGBColorSpace;
document.body.appendChild(renderer.domElement);

/* ======================
   SCENE / CAMERA
====================== */

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(60, innerWidth / innerHeight, 1, 8000);
camera.position.set(0, 900, 1400);

/* ======================
   CONTROLS
====================== */

const controls = new OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;
controls.dampingFactor = 0.08;
controls.minDistance = 400;
controls.maxDistance = 3000;
controls.maxPolarAngle = Math.PI / 2.1;

/* ======================
   BASIC ARENA MATERIAL
====================== */

const arenaBaseMaterial = new THREE.MeshStandardMaterial({
	color: 0x1a1a1a,
	roughness: 0.9,
	metalness: 0.1
});

scene.add(new THREE.AmbientLight(0x666666));
const sun = new THREE.DirectionalLight(0xffffff, 1.0);
sun.position.set(800, 1500, 600);
scene.add(sun);

/* ======================
   LOAD ARENA
====================== */

const loader = new OBJLoader();
loader.load("./arena.obj", obj => {
	obj.traverse(m => {
		if (!m.isMesh) return;
		m.material = arenaBaseMaterial;
	});
	scene.add(obj);
});

/* ======================
   RENDER TARGET (SCENE → TEXTURE)
====================== */

const renderTarget = new THREE.WebGLRenderTarget(innerWidth, innerHeight, {
	colorSpace: THREE.SRGBColorSpace
});

/* ======================
   PROJECTION SHADER MATERIAL
====================== */

const projectionMaterial = new THREE.ShaderMaterial({
	uniforms: {
		uTime: { value: 0 },
		uResolution: { value: new THREE.Vector2(innerWidth, innerHeight) },
		uScene: { value: renderTarget.texture }
	},
	vertexShader: `
		void main() {
			gl_Position = vec4(position, 1.0);
		}
	`,
	fragmentShader: `
		uniform float uTime;
		uniform vec2 uResolution;
		uniform sampler2D uScene;

		float rand(vec2 seed) {
			return fract(sin(dot(seed, vec2(12.9898,78.233))) * 43758.5453);
		}

		vec3 makeBlue(vec3 i) {
			return vec3(0.0, 0.0, (i.r + i.g + i.b) / 3.0);
		}

		vec3 Scanline(vec3 color, vec2 uv) {
			float scan = 0.95 + 0.05 * cos(3.14159 * (uv.y + uTime * 0.008) * 240.0);
			float grille = 0.85 + 0.15 * cos(3.14159 * uv.x * 640.0);
			return color * scan * grille * 1.2;
		}

		vec3 edgeSample(vec2 uv) {
			if (uv.x < 0.0 || uv.x > 1.0 || uv.y < 0.0 || uv.y > 1.0)
				return vec3(0.0);
			return texture2D(uScene, uv).rgb;
		}

		void main() {
			vec2 uv = gl_FragCoord.xy / uResolution;
			uv.y = 1.0 - uv.y;

			vec2 flickerUV = uv;
			flickerUV.x += rand(vec2(0.0, uv.y) * uTime) * 0.005;
			flickerUV.y += rand(vec2(0.0, uv.x) * uTime) * 0.005;

			vec3 col = edgeSample(flickerUV);
			col = Scanline(col, uv);
			col = makeBlue(col);

			gl_FragColor = vec4(col, 0.85);
		}
	`,
	transparent: true,
	depthWrite: false
});

/* ======================
   FULLSCREEN QUAD (OVERLAY)
====================== */

const quad = new THREE.Mesh(
	new THREE.PlaneGeometry(2, 2),
	projectionMaterial
);
quad.frustumCulled = false;

const postScene = new THREE.Scene();
const postCamera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);
postScene.add(quad);

/* ======================
   ANIMATE
====================== */

function animate() {
	projectionMaterial.uniforms.uTime.value = performance.now() * 0.001;
	controls.update();

	// 1️⃣ render arena to texture
	renderer.setRenderTarget(renderTarget);
	renderer.render(scene, camera);

	// 2️⃣ render projection overlay
	renderer.setRenderTarget(null);
	renderer.render(postScene, postCamera);
}
renderer.setAnimationLoop(animate);

/* ======================
   RESIZE
====================== */

window.addEventListener("resize", () => {
	camera.aspect = innerWidth / innerHeight;
	camera.updateProjectionMatrix();
	renderer.setSize(innerWidth, innerHeight);

	renderTarget.setSize(innerWidth, innerHeight);
	projectionMaterial.uniforms.uResolution.value.set(innerWidth, innerHeight);
});
</script>

</body>
</html>
